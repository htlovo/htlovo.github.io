3.5.1  一元操作符 

	1. 递增和递减操作符 
递增和递减操作符：前置型和后置型。
前置递增和递减操作是在语句被求值以前执行的。
后置递增和递减操作是在语句被求值之后执行的。

var num1 = 2; 
var num2 = 20; 
var num3 = --num1 + num2;      // 等于21 
var num4 = num1 + num2;       // 等于21 

num1 = 2; 
num3 = num1-- + num2;      // 等于22 
num4 = num1 + num2;       // 等于21

所有这4 个操作符对任何值都适用。在应用于不同的值时，递增和递减操作符遵循下列规则。 
	在应用于一个包含有效数字字符的字符串时，先将其转换为数字值，再执行加减1 的操作。字符串变量变成数值变量。 
	在应用于一个不包含有效数字字符的字符串时，将变量的值设置为NaN。字符串变量变成数值变量。 
	在应用于布尔值false 时，先将其转换为0 再执行加减1 的操作。布尔值变量变成数值变量。 
	在应用于布尔值true 时，先将其转换为1 再执行加减1 的操作。布尔值变量变成数值变量。 
	在应用于浮点数值时，执行加减1 的操作。 
	在应用于对象时，先调用对象的valueOf()方法以取得一个可供操作的值。然后对该值应用前述规则。如果结果是NaN ，则在调用toString()方法后再应用前述规则。对象变量变成数值变量。 

	2. 一元加和减操作符 
一元加操作符以一个加号（+ ）表示，放在数值前面，对数值不会产生任何影响，
不过，在对非数值应用一元加操作符时，该操作符会像Number() 转型函数一样对这个值执行转换。
布尔值 false 和true 将被转换为0 和1 ，字符串值会被按照一组特殊的规则进行解析，而
对象是先调用它们的valueOf()和（或）toString() 方法，再转换得到的值。

一元减操作符主要用于表示负数，
在将一元减操作符应用于数值时，该值会变成负数。而当应用于非数值时，
一元减操作符遵循与一元加操作符相同的规则，最后再将得到的数值转换为负数，

var num = 25; 
num = +num;     // 仍然是25 
num = -num;    //  变成了-25 

一元加和减操作符主要用于基本的算术运算，也可以像前面示例所展示的一样用于转换数据类型。 

3.5.2  位操作符 
位操作符用于在最基本的层次上，即按内存中表示数值的位来操作数值。ECMAScript 中的所有数
值都以IEEE-754 64 位格式存储，但位操作符并不直接操作 64位的值。而是先将 64位的值转换成32位
的整数，然后执行操作，最后再将结果转换回64位。对于开发人员来说，由于64位存储格式是透明的，
因此整个过程就像是只存在32位的整数一样。 
对于有符号的整数，32位中的前31位用于表示整数的值。第32位用于表示数值的符号：0 表示正
数，1 表示负数。这个表示符号的位叫做符号位，符号位的值决定了其他位数值的格式。其中，正数以
纯二进制格式存储，31位中的每一位都表示2 的幂。
负数同样以二进制码存储，但使用的格式是二进制补码。计算一个数值的二进制补码，需要经过下
列3 个步骤：
(1)  求这个数值绝对值的二进制码（例如，要求 18的二进制补码，先求18的二进制码）； 
(2)  求二进制反码，即将0 替换为1，将1 替换为0； 
(3)  得到的二进制反码加1。 
-18的二进制表示，即 11111111111111111111111111101110 。要注意的是，在处理有
符号整数时，是不能访问位31的。 
在以二进制字符串形式输出一个负数时，
我们看到的只是这个负数绝对值的二进制码前面加上了一个负号。
默认情况下，ECMAScript 中的所有整数都是有符号整数。不过，当然也存在无
符号整数。对于无符号整数来说，第32位不再表示符号，因为无符号整数只能是正
数。而且，无符号整数的值可以更大，因为多出的一位不再表示符号，可以用来表示
数值。 
在ECMAScript中，当对数值应用位操作符时，后台会发生如下转换过程：64位的数值被转换成32
位数值，然后执行位操作，最后再将 32位的结果转换回64位数值。这样，表面上看起来就好像是在操
作32位数值，就跟在其他语言中以类似方式执行二进制操作一样。但这个转换过程也导致了一个严重
的副效应，即在对特殊的NaN 和Infinity 值应用位操作时，这两个值都会被当成0 来处理。 
如果对非数值应用位操作符，会先使用Number() 函数将该值转换为一个数值（自动完成），然后
再应用位操作。得到的结果将是一个数值。 

	1. 按位非（NOT） 
按位非操作符由一个波浪线（~ ）表示，执行按位非的结果就是返回数值的反码。
 
var num1 = 25;         // 二进制00000000000000000000000000011001 
var num2 = ~num1;       // 二进制11111111111111111111111111100110 
alert(num2);              // -26 
 

按位非操作的本质：操作数的负值减 1 。

var num1 = 25; 
var num2 = -num1 - 1; 
alert(num2);            // "-26" 
 
虽然以上代码也能返回同样的结果，但由于按位非是在数值表示的最底层执行操作，因此速度更快。 
2. 按位与（AND） 
按位与操作符由一个和号字符（& ）表示，它有两个操作符数。从本质上讲，按位与操作就是将两
个数值的每一位对齐，然后根据下表中的规则，对相同位置上的两个数执行AND操作： 
 
按位与操作只在两个数值的对应位都是1 时才返回1，任何一位是0，结果都是0。 
下面看一个对25和3 执行按位与操作的例子： 
 
var result = 25 & 3; 
alert(result);     //1 
 
25  = 0000 0000 0000 0000 0000 0000 0001 1001 
3  = 0000 0000 0000 0000 0000 0000 0000 0011 
 --------------------------------------------- 
  AND = 0000 0000 0000 0000 0000 0000 0000 0001 

	3. 按位或（OR） 
按位或操作符由一个竖线符号（|）表示，同样也有两个操作数。按位或操作遵循下面这个真值表。 
 
按位或操作在有一个位是1 的情况下就返回 1，而只有在两个位都是 0 的情况下才返回 0。 

var result = 25 | 3; 
alert(result);       //27 
 
25 = 0000 0000 0000 0000 0000 0000 0001 1001 
3  = 0000 0000 0000 0000 0000 0000 0000 0011 
-------------------------------------------- 
OR = 0000 0000 0000 0000 0000 0000 0001 1011 

	4. 按位异或（XOR） 
按位异或操作符由一个插入符号（^ ）表示，也有两个操作数。以下是按位异或的真值表。 

按位异或与按位或的不同之处在于，这个操作在两个数值对应位上只有一个1 时才返回1，如果对
应的两位都是1 或都是0，则返回0。

var result = 25 ^ 3; 
alert(result);    //26 
 
25  = 0000 0000 0000 0000 0000 0000 0001 1001 
3  = 0000 0000 0000 0000 0000 0000 0000 0011 
 --------------------------------------------- 
 XOR  = 0000 0000 0000 0000 0000 0000 0001 1010 
 
注意这个结果比执行按位或时小1 

	5. 左移 
左移操作符由两个小于号（<<）表示，这个操作符会将数值的所有位向左移动指定的位数。  
 
var oldValue = 2;                       //  等于二进制的10 
var newValue = oldValue << 5;           //  等于二进制的1000000，十进制的64 

注意，在向左移位后，原数值的右侧多出了 5 个空位。左移操作会以 0 来填充这些空位，以便得到
的结果是一个完整的32位二进制数

注意，左移不会影响操作数的符号位。换句话说，如果将-2 向左移动 5 位，结果将是-64 ，而非 64 。 

	6. 有符号的右移 
有符号的右移操作符由两个大于号（>>）表示，这个操作符会将数值向右移动，但保留符号位（即
正负号标记）。有符号的右移操作与左移操作恰好相反，即如果将64向右移动5 位，结果将变回2： 
 
var oldValue = 64;                //  等于二进制的1000000 
var newValue = oldValue >> 5;     //  等于二进制的10  ，即十进制的2 
 

同样，在移位过程中，原数值中也会出现空位。只不过这次的空位出现在原数值的左侧、符号位的
右侧。而此时 ECMAScript会用符号位的值来填充所有空位，以便得到一个完整的值。 

	7. 无符号右移 
无符号右移操作符由3 个大于号（>>> ）表示，这个操作符会将数值的所有 32位都向右移动。对正
数来说，无符号右移的结果与有符号右移相同。仍以前面有符号右移的代码为例，如果将64无符号右
移5 位，结果仍然还是2： 
 
var oldValue = 64;                 //  等于二进制的1000000 
var newValue = oldValue >>> 5;     //  等于二进制的10  ，即十进制的2 

但是对负数来说，情况就不一样了。首先，无符号右移是以 0 来填充空位，而不是像有符号右移那
样以符号位的值来填充空位。所以，对正数的无符号右移与有符号右移结果相同，但对负数的结果就不
一样了。其次，无符号右移操作符会把负数的二进制码当成正数的二进制码。而且，由于负数以其绝对
值的二进制补码形式表示，因此就会导致无符号右移后的结果非常之大，

var oldValue = -64;                //  等于二进制的11111111111111111111111111000000 
var newValue = oldValue >>> 5;   // 00000111111111111111111111111110等于十进制的134217726 

3.5.3  布尔操作符 
布尔操作符的重要性堪比相等操作符。布尔操作符一共有3 个：非（NOT）、与（ AND）
和或（OR）。  
	1. 逻辑非 
逻辑非操作符由一个叹号（！）表示，可以应用于 ECMAScript中的任何值。无论这个值是什么数据
类型，这个操作符都会返回一个布尔值。逻辑非操作符首先会将它的操作数转换为一个布尔值，然后再
对其求反。也就是说，逻辑非操作符遵循下列规则： 
	如果操作数是一个对象，返回false ； 
	如果操作数是一个空字符串，返回true； 
	如果操作数是一个非空字符串，返回false； 
	如果操作数是数值0，返回true； 
	如果操作数是任意非0 数值（包括Infinity ），返回 false； 
	如果操作数是null，返回true； 
	如果操作数是NaN ，返回true； 
	如果操作数是undefined，返回true。 

逻辑非操作符也可以用于将一个值转换为与其对应的布尔值。而同时使用两个逻辑非操作符，实际
上就会模拟Boolean()转型函数的行为，最终结果与对这个值使用Boolean()函数相同。

	2. 逻辑与 
逻辑与操作符由两个和号（&&）表示，有两个操作数，
逻辑与的真值表如下： 
 
第一个操作数  第二个操作数  结  果 
true true true 
true false false 
false true  false 
false false false 
 
逻辑与操作可以应用于任何类型的操作数，而不仅仅是布尔值。在有一个操作数不是布尔值的情况
下，逻辑与操作就不一定返回布尔值；此时，它遵循下列规则： 
	如果第一个操作数是对象，则返回第二个操作数； 
	如果第二个操作数是对象，则只有在第一个操作数的求值结果为 true 的情况下才会返回该 
对象； 
	如果两个操作数都是对象，则返回第二个操作数； 
	如果有一个操作数是null，则返回null； 
	如果有一个操作数是NaN ，则返回NaN ； 
	如果有一个操作数是undefined，则返回undefined。 
逻辑与操作属于短路操作，即如果第一个操作数能够决定结果，那么就不会再对第二个操作数求值。
对于逻辑与操作而言，如果第一个操作数是 false ，则无论第二个操作数是什么值，结果都不再可能是
true 了。来看下面的例子： 
 
var found = true; 
var result = (found && someUndefinedVariable);    //  这里会发生错误 
alert(result);    //  这一行不会执行 
 
LogicalAndExample01.htm 
在上面的代码中，当执行逻辑与操作时会发生错误，因为变量someUndefinedVariable 没有声
明。由于变量 found 的值是true，所以逻辑与操作符会继续对变量 someUndefinedVariable 求值。
但someUndefinedVariable 尚未定义，因此就会导致错误。这说明不能在逻辑与操作中使用未定义
的值。如果像下面这个例中一样，将found的值设置为false ，就不会发生错误了： 
 
var found = false; 
var result = (found && someUndefinedVariable);     // 不会发生错误 
alert(result);    //  会执行（"false"） 
 
在这个例子中，警告框会显示出来。无论变量someUndefinedVariable 有没有定义，也永远不
会对它求值，因为第一个操作数的值是 false。而这也就意味着逻辑与操作的结果必定是 false ，根本
用不着再对&&右侧的操作数求值了。在使用逻辑与操作符时要始终铭记它是一个短路操作符。 
	3. 逻辑或 
逻辑或操作符由两个竖线符号（||）表示，有两个操作数，
逻辑或的真值表如下： 
 
第一个操作数  第二个操作数  结  果 
True true true 
True false true 
false true  true 
false false false 
 
与逻辑与操作相似，如果有一个操作数不是布尔值，逻辑或也不一定返回布尔值；此时，它遵循下
列规则： 
	如果第一个操作数是对象，则返回第一个操作数； 
	如果第一个操作数的求值结果为false ，则返回第二个操作数； 
	如果两个操作数都是对象，则返回第一个操作数； 
	如果两个操作数都是null，则返回null； 
	如果两个操作数都是NaN ，则返回NaN ； 
	如果两个操作数都是undefined，则返回undefined。 
与逻辑与操作符相似，逻辑或操作符也是短路操作符。也就是说，如果第一个操作数的求值结果为
true，就不会对第二个操作数求值了。下面看一个例子： 
 
var found = true; 
var result = (found || someUndefinedVariable);     // 不会发生错误 
alert(result);    //  会执行（"true" ） 
 
LogicalOrExample01.htm 
这个例子跟前面的例子一样，变量 someUndefinedVariable 也没有定义。但是，由于变量found
的值是true，而变量someUndefinedVariable 永远不会被求值，因此结果就会输出"true"。如果
像下面这个例子一样，把found的值改为false ，就会导致错误： 
 
var found = false; 
var result = (found || someUndefinedVariable);     // 这里会发生错误 
alert(result);    //  这一行不会执行 
 
LogicalOrExample02.htm 
我们可以利用逻辑或的这一行为来避免为变量赋null 或undefined 值。例如： 
 
var myObject = preferredObject || backupObject; 
 
在这个例子中，变量 myObject 将被赋予等号后面两个值中的一个。变量 preferredObject 中包
含优先赋给变量myObject 的值，变量backupObject负责在preferredObject中不包含有效值的
情况下提供后备值。如果preferredObject的值不是null，那么它的值将被赋给myObject ；如果
是null，则将 backupObject的值赋给myObject 。ECMAScript程序的赋值语句经常会使用这种模式，
本书也将采用这种模式

3.5.4  乘性操作符 
ECMAScript定义了3 个乘性操作符：乘法、除法和求模。在操作数为非数值的情况下会执行自动的类型转换。如果参与乘性计算的某
个操作数不是数值，后台会先使用Number() 转型函数将其转换为数值。也就是说，空字符串将被当作
0，布尔值true 将被当作1 。 
	1. 乘法 
乘法操作符由一个星号（* ）表示，用于计算两个数值的乘积。

在处理特殊值的情况下，乘法操作符遵循下列特殊的规则： 
	如果操作数都是数值，执行常规的乘法计算，即两个正数或两个负数相乘的结果还是正数，而
如果只有一个操作数有符号，那么结果就是负数。如果乘积超过了ECMAScript数值的表示范围，
则返回Infinity 或-Infinity； 
	如果有一个操作数是NaN ，则结果是NaN ； 
	如果是Infinity 与0 相乘，则结果是NaN ； 
	如果是Infinity 与非0 数值相乘，则结果是Infinity 或-Infinity，取决于有符号操作数
的符号； 
	如果是Infinity 与Infinity 相乘，则结果是Infinity ； 
	如果有一个操作数不是数值，则在后台调用 Number() 将其转换为数值，然后再应用上面的 
规则。 
	2. 除法 
除法操作符由一个斜线符号（/ ）表示，执行第二个操作数除第一个操作数的计算，
 
与乘法操作符类似，除法操作符对特殊的值也有特殊的处理规则。这些规则如下： 
	如果操作数都是数值，执行常规的除法计算，即两个正数或两个负数相除的结果还是正数，而
如果只有一个操作数有符号，那么结果就是负数。如果商超过了ECMAScript数值的表示范围，
则返回Infinity 或-Infinity； 
	如果有一个操作数是NaN ，则结果是NaN ； 
	如果是Infinity 被Infinity 除，则结果是NaN ； 
	如果是零被零除，则结果是NaN ； 
  如果是非零的有限数被零除，则结果是 Infinity 或-Infinity，取决于有符号操作数的符号； 
	如果是Infinity 被任何非零数值除，则结果是Infinity 或-Infinity，取决于有符号操作
数的符号； 
  如果有一个操作数不是数值，则在后台调用Number()将其转换为数值，然后再应用上面的规则。 
	3. 求模 
求模（余数）操作符由一个百分号（% ）表示， 
 
与另外两个乘性操作符类似，求模操作符会遵循下列特殊规则来处理特殊的值： 
	如果操作数都是数值，执行常规的除法计算，返回除得的余数； 
	如果被除数是无穷大值而除数是有限大的数值，则结果是NaN ； 
	如果被除数是有限大的数值而除数是零，则结果是NaN ； 
	如果是Infinity 被Infinity 除，则结果是NaN ； 
	如果被除数是有限大的数值而除数是无穷大的数值，则结果是被除数； 
	如果被除数是零，则结果是零； 
  如果有一个操作数不是数值，则在后台调用Number()将其转换为数值，然后再应用上面的规则。 

3.5.5  加性操作符 
加法和减法这两个加性操作符应该说是编程语言中最简单的算术操作符了。但是在ECMAScript中，
这两个操作符却都有一系列的特殊行为。与乘性操作符类似，加性操作符也会在后台转换不同的数据类
型。然而，对于加性操作符而言，相应的转换规则还稍微有点复杂。 
	1. 加法 
加法操作符（+）的用法如下所示： 
 
var result = 1 + 2; 
 
如果两个操作符都是数值，执行常规的加法计算，然后根据下列规则返回结果： 
	如果有一个操作数是NaN ，则结果是NaN ； 
	如果是Infinity 加Infinity ，则结果是Infinity ； 
	如果是-Infinity 加-Infinity，则结果是-Infinity； 
	如果是Infinity 加-Infinity，则结果是NaN ； 
	如果是+0加+0，则结果是+0； 
	如果是-0加-0 ，则结果是-0 ； 
	如果是+0加-0 ，则结果是+0。 
不过，如果有一个操作数是字符串，那么就要应用如下规则： 
	如果两个操作数都是字符串，则将第二个操作数与第一个操作数拼接起来； 
	如果只有一个操作数是字符串，则将另一个操作数转换为字符串，然后再将两个字符串拼接 
起来。 
如果有一个操作数是对象、数值或布尔值，则调用它们的toString() 方法取得相应的字符串值，
然后再应用前面关于字符串的规则。对于 undefined 和null，则分别调用 String() 函数并取得字符
串"undefined"和"null"。 

 
var result1 = 5 + 5;       //  两个数值相加 
alert(result1);           // 10 
 
var result2 = 5 + "5";     //  一个数值和一个字符串相加 
alert(result2);           // "55" 

以上代码演示了加法操作符在两种模式下的差别。第一行代码演示了正常的情况，即5+5 等于10
（数值）。但是，如果将一个操作数改为字符串"5" ，结果就变成了"55"（字符串值），因为第一个操作
数也被转换成了"5" 。 
忽视加法操作中的数据类型是ECMAScript编程中最常见的一个错误。再来看一个例子： 
 
var num1 = 5; 
var num2 = 10; 
var message = "The sum of 5 and 10 is " + num1 + num2; 
alert(message);    // "The sum of 5 and 10 is 510" 

变量message 的值是执行两个加法操作之后的结果。如果想先对数值执行算术计算，然后再将结果与字符串拼接起来，应该像下面这样使用
圆括号： 
 
var num1 = 5; 
var num2 = 10; 
var message = "The sum of 5 and 10 is " + (num1 + num2); 
alert(message);    //"The sum of 5 and 10 is 15" 
 
	2. 减法 
减法操作符（ ）是另一个极为常用的操作符，其用法如下所示： 
 
var result = 2 - 1; 
 
与加法操作符类似，ECMAScript 中的减法操作符在处理各种数据类型转换时，同样需要遵循一些
特殊规则，如下所示： 
	如果两个操作符都是数值，则执行常规的算术减法操作并返回结果； 
	如果有一个操作数是NaN ，则结果是NaN ； 
	如果是Infinity 减Infinity ，则结果是NaN ； 
	如果是-Infinity 减-Infinity，则结果是NaN ； 
	如果是Infinity 减-Infinity，则结果是Infinity ； 
	如果是-Infinity 减Infinity ，则结果是-Infinity； 
	如果是+0减+0，则结果是+0； 
	如果是+0减-0 ，则结果是-0 ； 
	如果是-0减-0 ，则结果是+0； 
	如果有一个操作数是字符串、布尔值、null 或undefined，则先在后台调用 Number() 函数将
其转换为数值，然后再根据前面的规则执行减法计算。如果转换的结果是NaN ，则减法的结果
就是NaN ； 
	如果有一个操作数是对象，则调用对象的valueOf()方法以取得表示该对象的数值。如果得到
的值是NaN ，则减法的结果就是NaN 。如果对象没有valueOf()方法，则调用其toString()
方法并将得到的字符串转换为数值。 

3.5.6  关系操作符 
小于（< ）、大于（> ）、小于等于（<=）和大于等于（>=）这几个关系操作符用于对两个值进行比
较，比较的规则与我们在数学课上所学的一样。这几个操作符都返回一个布尔值

与ECMAScript中的其他操作符一样，当关系操作符的操作数使用了非数值时，也要进行数据转换
或完成某些奇怪的操作。以下就是相应的规则。 
	如果两个操作数都是数值，则执行数值比较。 
	如果两个操作数都是字符串，则比较两个字符串对应的字符编码值。 
	如果一个操作数是数值，则将另一个操作数转换为一个数值，然后执行数值比较。 
	如果一个操作数是对象，则调用这个对象的valueOf()方法，用得到的结果按照前面的规则执
行比较。如果对象没有valueOf()方法，则调用toString()方法，并用得到的结果根据前面
的规则执行比较。 
	如果一个操作数是布尔值，则先将其转换为数值，然后再执行比较。 
在使用关系操作符比较两个字符串时，会执行一种奇怪的操作。很多人都会认为，在比较字符串值
时，小于的意思是“在字母表中的位置靠前”，而大于则意味着“在字母表中的位置靠后”，但实际上完
全不是那么回事。在比较字符串时，实际比较的是两个字符串中对应位置的每个字符的字符编码值。
 
var result = "Brick" < "alphabet";    //true 
 
如果要真正按字母表顺序比较字符串，就必须把两个操作数转换为相同的大
小写形式（全部大写或全部小写），然后再执行比较，如下所示： 
 
var result = "Brick".toLowerCase() < "alphabet".toLowerCase(); //false 
 
通过将两个操作数都转换为小写形式，就可以得出"alphabet"按字母表顺序排在"Brick"之前的
正确判断了。 
另一种奇怪的现象发生在比较两个数字字符串的情况下，比如下面这个例子： 
 
var result = "23" < "3";    //true 
 
确实，当比较字符串"23"是否小于"3" 时，结果居然是true。这是因为两个操作数都是字符串，
而字符串比较的是字符编码（"2" 的字符编码是50，而"3" 的字符编码是51）。不过，如果像下面例子
中一样，将一个操作数改为数值，比较的结果就正常了： 
 
var result = "23" < 3;    //false 
 
此时，字符串"23"会被转换成数值23，然后再与3 进行比较，因此就会得到合理的结果。在比较
数值和字符串时，字符串都会被转换成数值，然后再以数值方式与另一个数值比较。当然，这个规则对
前面的例子是适用的。可是，如果那个字符串不能被转换成一个合理的数值呢？比如： 
 
var result = "a" < 3;    // false ，因为"a" 被转换成了NaN 
 
由于字母"a" 不能转换成合理的数值，因此就被转换成了 NaN 。根据规则，任何操作数与 NaN 进行
关系比较，结果都是false 。

3.5.7  相等操作符 
在比较字符串、数值和布尔值的相等性时，
问题还比较简单。但在涉及到对象的比较时，问题就变得复杂了。最早的ECMAScript中的相等和不等
操作符会在执行比较之前，先将对象转换成相似的类型。后来，有人提出了这种转换到底是否合理的质
疑。最后，ECMAScript 的解决方案就是提供两组操作符：相等和不相等——先转换再比较， 全等和不
全等——仅比较而不转换。 
	1. 相等和不相等 
ECMAScript中的相等操作符由两个等于号（==）表示，如果两个操作数相等，则返回 true。而不
相等操作符由叹号后跟等于号（!=）表示，如果两个操作数不相等，则返回true。这两个操作符都会
先转换操作数（通常称为强制转型），然后再比较它们的相等性。  
在转换不同的数据类型时，相等和不相等操作符遵循下列基本规则： 
	如果有一个操作数是布尔值，则在比较相等性之前先将其转换为数值——false 转换为0，而
true 转换为1 ； 
 
	如果一个操作数是字符串，另一个操作数是数值，在比较相等性之前先将字符串转换为数值； 
	如果一个操作数是对象，另一个操作数不是，则调用对象的valueOf()方法，用得到的基本类
型值按照前面的规则进行比较； 
这两个操作符在进行比较时则要遵循下列规则。 
	null 和undefined 是相等的。 
	要比较相等性之前，不能将null 和undefined 转换成其他任何值。 
	如果有一个操作数是NaN ，则相等操作符返回false ，而不相等操作符返回true。重要提示：
即使两个操作数都是NaN ，相等操作符也返回false ；因为按照规则，NaN 不等于NaN 。 
	如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，
则相等操作符返回true；否则，返回false。      
 
	2. 全等和不全等 
除了在比较之前不转换操作数之外，全等和不全等操作符与相等和不相等操作符没有什么区别。全
等操作符由3 个等于号（=== ）表示，它只在两个操作数未经转换就相等的情况下返回 true

记住：null == undefined 会返回true，因为它们是类似的值；但null === undefined 会返

回false ，因为它们是不同类型的值。 
由于相等和不相等操作符存在类型转换问题，而为了保持代码中数据类型的完整
性，我们推荐使用全等和不全等操作符。

3.5.8  条件操作符 
条件操作符应该算是ECMAScript中最灵活的一种操作符了

variable = boolean_expression ? true_value : false_value; 
 
本质上，这行代码的含义就是基于对boolean_expression 求值的结果，决定给变量variable
赋什么值。如果求值结果为true，则给变量variable 赋true_value 值；如果求值结果为false，
则给变量variable 赋false_value 值。再看一个例子： 
 
var max = (num1 > num2) ? num1 : num2; 
 
在这个例子中，max 中将会保存一个最大的值。

3.5.9  赋值操作符 
简单的赋值操作符由等于号（=）表示，其作用就是把右侧的值赋给左侧的变量，如下面的例子所示： 
 
var num = 10; 
 
如果在等于号（= ）前面再添加乘性操作符、加性操作符或位操作符，就可以完成复合赋值操作。
这种复合赋值操作相当于是对下面常规表达式的简写形式： 
 
var num = 10; 
num = num + 10; 
 
其中的第二行代码可以用一个复合赋值来代替： 
 
var num = 10; 
num += 10; 
 
每个主要算术操作符（以及个别的其他操作符）都有对应的复合赋值操作符。这些操作符如下所示： 
	乘/赋值（*=）； 
	除/赋值（/=）； 
	模/赋值（%=）； 
	加/赋值（+=）； 
	减/赋值（-=）； 
	左移/赋值（<<= ）； 
	有符号右移/赋值（>>= ）； 
	无符号右移/赋值（>>>=）。  
设计这些操作符的主要目的就是简化赋值操作。使用它们不会带来任何性能的提升。 

3.5.10   逗号操作符 
使用逗号操作符可以在一条语句中执行多个操作，如下面的例子所示： 
 
var num1=1, num2=2, num3=3; 
 
逗号操作符多用于声明多个变量；但除此之外，逗号操作符还可以用于赋值。在用于赋值时，逗号
操作符总会返回表达式中的最后一项，如下面的例子所示： 
 
var num = (5, 1, 4, 8, 0); // num 的值为0 
 
由于0 是表达式中的最后一项，因此 num 的值就是0 。虽然逗号的这种使用方式并不常见，但这个
例子可以帮我们理解逗号的这种行为。 




3.5.1  一元操作符 
	1. 递增和递减操作符	(a++,++a,a--,--a)
	2. 一元加和减操作符	(+a,-a)
3.5.2  位操作符 
	1. 按位非（NOT）	(~a)
	2. 按位与（AND）	(a&b)
	3. 按位或（OR）		(a|b)
	4. 按位异或（XOR）	(a^b)
	5. 左移				(a<<b)
	6. 有符号的右移		(a>>b)
	7. 无符号右移		(a>>>b)
3.5.3  布尔操作符 
	1. 逻辑非			(!a)
	2. 逻辑与			(a&&b)
		如果第一个操作数的Boolean()函数值为false，则结果为第一个操作数（短路），否则为第二个操作数
	3. 逻辑或			(a||b)
		如果第一个操作数的Boolean()函数值为true，则结果为第一个操作数（短路），否则为第二个操作数
3.5.4  乘性操作符 
	1. 乘法				(a*b)
	2. 除法				(a/b)
	3. 求模				(a%b)
3.5.5  加性操作符 
	1. 加法				(a+b)
	2. 减法				(a-b)
3.5.6  关系操作符		(a<b,a>b,a<=b,a>=b)
3.5.7  相等操作符		
	1. 相等和不相等		(a==b,a!=b)
	2. 全等和不全等		(a===b,a!==b)
3.5.8  条件操作符		(a?b:c)
3.5.9  赋值操作符		(a=b,a*=b,a/=b,a%=b,a+=b,a-=b,a<<=b,a>>=b,a>>>=b)
3.5.10  逗号操作符		(,)

有一些表达式则具有很多副作用，前后的表达式运算会相互影响。赋值运算符是最明显的一个例子：如果给一个变量或属性赋值，那么那些使用这个变量或属性的表达式的值都会发生改变。“++”和“--”递增和递减运算符与此类似，因为它们包含隐式的赋值。delete运算符同样有副作用：删除一个属性就像（但不完全一样）给这个属性赋值undefined。

其他的JavaScript运算符都没有副作用，但函数调用表达式和对象创建表达式有些特别，在函数体或者构造函数内部运用了这些运算符并产生了副作用的时候，我们说函数调用表达式和对象创建表达式是有副作用的。

属性访问表达式和调用表达式的优先级要比表4-1中列出的所有运算符都要高。












来源：
js高级程序设计